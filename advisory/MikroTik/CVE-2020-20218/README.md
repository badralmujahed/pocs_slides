### CVE-2020-20218

#### Description

The `traceroute` process suffers from a memory corruption vulnerability. By sending a crafted packet, an authenticated remote user can crash the `traceroute` process, for the count of loop operation is controllable.

Against stable `6.46.3`, the poc resulted in the following crash captured by `gdb`.

```shell
(gdb) c                                               
Continuing.                                           
                                                      
Program received signal SIGSEGV, Segmentation fault.  
=> 0x804da3e:   rep stos BYTE PTR es:[edi],al         
   0x804da40:   jne    0x804da81                      
   0x804da42:   mov    eax,DWORD PTR [ebx+0x50]       
   0x804da45:   mov    ecx,DWORD PTR [ebx+0x4]        
0x0804da3e in ?? ()                                   
(gdb) i r                                             
eax            0x0      0                             
ecx            0xfdffd1 16646097    <=== controllable                      
edx            0x7e9df530       2124281136            
ebx            0x8052848        134555720             
esp            0x7e9df530       0x7e9df530            
ebp            0x7f9bf5c8       0x7f9bf5c8            
esi            0x7e9df538       2124281144            
edi            0x7e9df538       2124281144            
eip            0x804da3e        0x804da3e             
eflags         0x10297  [ CF PF AF SF IF RF ]         
cs             0x73     115                           
ss             0x7b     123                           
ds             0x7b     123                           
es             0x7b     123                           
fs             0x0      0                             
gs             0x33     51                            
(gdb) info inferiors                                  
  Num  Description       Executable                   
* 1    process 455       target:/nova/bin/traceroute  
```

And the crash dump in `/rw/logs/backtrace.log` was:

```shell
# cat /rw/logs/backtrace.log
2020.05.16-21:51:49.43@0: 
2020.05.16-21:51:49.43@0: 
2020.05.16-21:51:49.43@0: /nova/bin/traceroute
2020.05.16-21:51:49.43@0: --- signal=11 --------------------------------------------
2020.05.16-21:51:49.43@0: 
2020.05.16-21:51:49.43@0: eip=0x0804da3e eflags=0x00010297
2020.05.16-21:51:49.43@0: edi=0x7e9df538 esi=0x7e9df538 ebp=0x7f9bf5c8 esp=0x7e9df530
2020.05.16-21:51:49.43@0: eax=0x00000000 ebx=0x08052848 ecx=0x00fdffd1 edx=0x7e9df530
2020.05.16-21:51:49.43@0: 
2020.05.16-21:51:49.43@0: maps:
2020.05.16-21:51:49.43@0: 08048000-0804f000 r-xp 00000000 00:0c 1007       /nova/bin/traceroute
2020.05.16-21:51:49.43@0: 77705000-7773a000 r-xp 00000000 00:0c 964        /lib/libuClibc-0.9.33.2.so
2020.05.16-21:51:49.43@0: 7773e000-77758000 r-xp 00000000 00:0c 960        /lib/libgcc_s.so.1
2020.05.16-21:51:49.43@0: 77759000-77768000 r-xp 00000000 00:0c 944        /lib/libuc++.so
2020.05.16-21:51:49.43@0: 77769000-77773000 r-xp 00000000 00:0c 961        /lib/libm-0.9.33.2.so
2020.05.16-21:51:49.43@0: 77775000-777c1000 r-xp 00000000 00:0c 946        /lib/libumsg.so
2020.05.16-21:51:49.43@0: 777c7000-777ce000 r-xp 00000000 00:0c 958        /lib/ld-uClibc-0.9.33.2.so
2020.05.16-21:51:49.43@0: 
2020.05.16-21:51:49.43@0: stack: 0x7f9c0000 - 0x7e9df530
```

#### Details

The vulnerability can be triggered by sending a nova message to the default handler. In its default handler vtable, the default `nv::Handler::handleCmd()` is overwritten by `sub_804C820()`.

In `sub_804C820()`, if `a3` equals to `0xfe000f`, then the value of u32_id `5` will be read and saved at `(2)`. At `(3)`, there is a signed comparison. If it satisfy, in normal cases the routine will reach `(4)`, where `sub_804D892()` will be called.

```c++
// file: /nova/bin/traceroute in stable 6.46.3
int sub_804C820(nv::Looper *a1, nv::message *a2, unsigned int a3)
{
  if ( a3 == 0xFE000F )  // (1) command id
  {
    /* ... */
    v3[19] = -1;
    v3[20] = 0;
    v3[21] = -1;
    /* ... */
    v3[19] = nv::message::get<nv::u32_id>(a2, 15, v3[19]);
    v12 = nv::message::get<nv::u32_id>(a2, 16, v3[21]);
    v3[21] = v12;
    if ( !v3[3] )
      v3[12] = 0;
    if ( nv::message::get<nv::u32_id>(a2, 5, v12, v12) )
    {
      v13 = IPAddr6::isIPv4(v28);
      if ( (_BYTE)v13 )
        v14 = nv::message::get<nv::u32_id>(a2, 5, v13, v13) - 20;
      else
        v14 = nv::message::get<nv::u32_id>(a2, 5, v13, v13) - 40;
      v3[15] = v14;     // (2) [v3 + 0x3C] = v18
    }
    if ( v3[15] > 7 )   // (3) signed comparison
    {
      if ( v3[19] )
      {
        v15 = v3[21];
        if ( v15 )
        {
          /* ... */
          if ( v3[2] >= 0 )
          {
            /* ... */
            sub_804D892((int)v3);  // (4)
            /* ... */
            
```

In `sub_804D892()`, the value saved at `a1 + 0x3c` will be read and assigned to `v11` at `(5)`. Exactly, this value is the previous value read from nova message, and controllable. At `(6)` `v11` will be passed to `alloca()` for stack space allocation. Since there is lack of proper validation on this value, if we provide a big value, we can cause the stack overlapping with library memory at `(6)`. Later when calling `memset()`, invalid memory access would occur.

```c++
void sub_804D892(int a1)
{
  /* ... */
  v11 = *(_DWORD *)(a1 + 0x3C);  // (5)
  v12 = alloca(v11);  // (6) controllable stack space allocation
  v13 = *(_DWORD *)(a1 + 12) == 1;
  memset(&v33, 0, v11 - 8);  // (7) &v33=v12+8
  /* ... */
```

#### Affected Version

This vulnerability was initially found in long-term  `6.44.6`, and was fixed in stable  `6.46.5` .

#### Timeline

+ 2020/01/06 - report the vulnerability to the vendor
+ 2020/01/08 - vendor confirms the vulnerability and fix it in Testing release tree
+ 2020/04/08 - vendor fix it in stable `6.46.5`
+ 2021/05/04 - CVE is assigned